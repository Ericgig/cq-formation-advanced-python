<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Calcul Québec: Advanced and Parallel Python</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <img style="height: 50px; margin-top: 20px;" src="img/logo-universite-laval.jpg" />
        <a href="http://www.calculquebec.ca" title="Calcul Québec"><img style="height: 70px; float: right; margin-top: 10px;" src="img/calculquebec_logo_small.jpg" /></a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <a href="index.html"><h1 class="title">Advanced and Parallel Python</h1></a>
          <h2 class="subtitle">Compiling Python Code</h2>
          <p>While it might seem unintuitive to talk about compiling an interpreted language, it is often an easy and overlooked solution to speeding up Python programs. The advantage of being an interpreted language is that most Python compilers do <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">Just-In-Time (JIT) compilation</a>, not unlike what <a href="http://pypy.org">PyPy</a> is doing.</p>
<h3 id="cython">Cython</h3>
<p>We’ll first have a look at the Cython (not to be confused with CPython). It has both pre-compilation and just-in-time compilation modes. We will use the former for now as it will help us understand what it’s doing and make better use of it.</p>
<p>It is important to note that Cython scripts use extensions to the language and as such, scripts must not end with the .py extension. The recommended extension is .pyx. Let’s make a copy of our initial script:</p>
<pre class="input"><code>$ cp approx_pi.py approx_pi_cython.pyx</code></pre>
<p>The relevant part of our file should look like this:</p>
<pre class="input"><code>$ cat approx_pi_cython.pyx</code></pre>
<pre class="output"><code>...
def approx_pi(intervals):
    pi = 0.0
    for i in range(intervals):
        pi += (4 - 8 * (i % 2)) / (float)(2 * i + 1)
    return pi
...</code></pre>
<p>To define compilation steps, we must create a compilation script, written in Python. A simple one, found in the setup_cython.py file, would look like this:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> distutils.core <span class="im">import</span> setup
<span class="im">from</span> Cython.Build <span class="im">import</span> cythonize
setup(ext_modules <span class="op">=</span> cythonize(<span class="st">&quot;*.pyx&quot;</span>))</code></pre></div>
<p>And to proceed with the compilation:</p>
<pre class="input"><code>$ python setup_cython.py build_ext --inplace</code></pre>
<p>After some compilation steps involving your C compiler (GCC, clang, icc, …), you will get, on Unix platforms, a shared library named approx_pi_cython.so. This is very different than what we did with PyPy in that this is not immediately executable: it’s only a library exposing functions so our main timing code cannot be executed. To use our newly compiled function, we need to import it in a script or in a Python interpreter:</p>
<pre class="input"><code>$ ipython</code></pre>
<pre class="output"><code>In [1]: from approx_pi_cython import approx_pi
In [2]: %timeit approx_pi(100000000)
1 loops, best of 3: 20.4 s per loop</code></pre>
<p>As you can see, we are not even twice as fast as our original Python code under CPython. To see why, we have to look at the generated C code in approx_pi_cython.c:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"> PyObject *__pyx_v_pi = NULL;
[...]
  <span class="co">/* &quot;approx_pi_cython.pyx&quot;:6</span>
<span class="co"> *</span>
<span class="co"> * def approx_pi(intervals):</span>
<span class="co"> *     pi = 0.0             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="co"> *     for i in range(intervals):</span>
<span class="co"> *         pi += (4 - 8 * (i % 2)) / (float)(2 * i + 1)</span>
<span class="co"> */</span>
  __Pyx_INCREF(__pyx_float_0_0);
  __pyx_v_pi = __pyx_float_0_0;</code></pre></div>
<p>This is only a snippet of the entire code but it’s enough to understand what’s going on. First, you’ll notice you have a C comment with an arrow pointing to the line the next code refers to. This is helpful to know how a line or chunk of code has been translated to C. Second, we notice that our pi variable is not a double native type, as we would expect, but a Python object. That means every interaction with that variable cannot be native C code and must go back inside the Python VM, as seen in this snippet:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">...
    __pyx_t_5 = PyNumber_Multiply(__pyx_int_8, __pyx_t_2); ...
...</code></pre></div>
<p>So even for basic arithmetic operations like multiplications, Python is involved. Going back and forth between C/Python that way explains why we don’t get really better performance. But there is a way to help the Cython compiler and give it hint about data types. This is where we begin using language extensions, as in the approx_pi_cython2.pyx file:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> approx_pi(<span class="bu">int</span> intervals):
    cdef double pi
    cdef <span class="bu">int</span> i
    pi <span class="op">=</span> <span class="fl">0.0</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(intervals):
        pi <span class="op">+=</span> (<span class="dv">4</span> <span class="op">-</span> <span class="dv">8</span> <span class="op">*</span> (i <span class="op">%</span> <span class="dv">2</span>)) <span class="op">/</span> (<span class="bu">float</span>)(<span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>)
    <span class="cf">return</span> pi</code></pre></div>
<p>All we did was add types to the input parameter (int), as well the two local variable pi and i (cdef double). Let’s compile and run it to compare:</p>
<pre class="input"><code>$ python setup_cython.py build_ext --inplace
...
$ ipython</code></pre>
<pre class="output"><code>In [1]: from approx_pi_cython import approx_pi
In [2]: %timeit approx_pi(100000000)
1 loop, best of 3: 711 ms per loop</code></pre>
<p>We are now on par with the PyPy interpreter. One could argue that using PyPy is easier than compiling with Cython and they would have a point: PyPy doesn’t require a C compiler nor a setup script to work. However, Cython will integrate with other C extensions. Let’s try to do better with Cython by looking again at the generated C code:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">...
  <span class="dt">double</span> __pyx_v_pi;
  <span class="dt">int</span> __pyx_v_i;
...
  __pyx_v_pi = <span class="fl">0.0</span>;
...
    <span class="co">/* &quot;approx_pi_cython2.pyx&quot;:6</span>
<span class="co"> *     pi = 0.0</span>
<span class="co"> *     for i in range(intervals):</span>
<span class="co"> *         pi += (4 - 8 * (i % 2)) / (float)(2 * i + 1)             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="co"> *     return pi</span>
<span class="co"> */</span>
    __pyx_t_3 = (<span class="dv">4</span> - (<span class="dv">8</span> * __Pyx_mod_long(__pyx_v_i, <span class="dv">2</span>)));</code></pre></div>
<p>Everything looks almost right. Our variables are now native types (double and int). The only thing left is this call to __Pyx_mod_long instead of the (way faster) C modulo operator (%). This is done mainly because of different behavior when using negative numbers. In C, -1%10 == -1 and in Python, -1%10 == 9. Since we know we won’t have any negative numbers going from 0 to intervals-1, we can safely tell the Cython compiler to use the native modulo operator:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#cython:cdivision=True</span>
<span class="kw">def</span> approx_pi(<span class="bu">int</span> intervals):
    cdef double pi
    cdef <span class="bu">int</span> i
    pi <span class="op">=</span> <span class="fl">0.0</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(intervals):
        pi <span class="op">+=</span> (<span class="dv">4</span> <span class="op">-</span> <span class="dv">8</span> <span class="op">*</span> (i <span class="op">%</span> <span class="dv">2</span>)) <span class="op">/</span> (<span class="bu">float</span>)(<span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>)
    <span class="cf">return</span> pi</code></pre></div>
<p>And we compile yet again our Cython code:</p>
<pre class="input"><code>$ python setup_cython.py build_ext --inplace
...
$ ipython</code></pre>
<pre class="output"><code>In [1]: from approx_pi_cython import approx_pi
In [2]: %timeit approx_pi(100000000)
1 loop, best of 3: 414 ms per loop</code></pre>
<p>We are now as fast as our first C code. I will let you have a look for yourself at the generated C code to confirm that the C modulo operator was indeed used.</p>
<p>A last note about Cython: we have learned how to compile our libraries but Cython also supports JIT compilation just by importing and running a statement before using our function:</p>
<pre class="input"><code>$ make clean &amp;&amp; ipython</code></pre>
<pre class="output"><code>In [1]: import pyximport; pyximport.install()
In [2]: from approx_pi_cython import approx_pi
In [3]: %timeit approx_pi(100000000)
1 loop, best of 3: 407 ms per loop</code></pre>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="data-processing"><span class="glyphicon glyphicon-pencil"></span>Data Processing</h2>
</div>
<div class="panel-body">
<p>Try optimizing the exercices/process_data.py script using the Cython compiler. What speedup can you achieve?</p>
<p><strong>Tip</strong>: Before running the script, make a copy, generate a random sample and work on the pyx file:</p>
<pre class="input"><code>cd exercices/ &amp;&amp; python gen_inputs.py &amp;&amp; cp process_data.py process_data.pyx</code></pre>
<p>A possible solution can be found in the solutions/process_data_cython.py file.</p>
</div>
</section>
<h3 id="numba">Numba</h3>
<p>Another option for JIT compiling is the <a href="http://numba.pydata.org/">Numba project</a>. The Numba compiler is provided by Continuum Analytics, which also distribute the Anaconda Python distribution. In its simpler form, you only need to add the <span class="citation">@jit</span> annotation to the code you want to speed up:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> numba <span class="im">import</span> jit

<span class="at">@jit</span>
<span class="kw">def</span> approx_pi(intervals):
    pi <span class="op">=</span> <span class="fl">0.0</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(intervals):
        pi <span class="op">+=</span> (<span class="dv">4</span> <span class="op">-</span> <span class="dv">8</span> <span class="op">*</span> (i <span class="op">%</span> <span class="dv">2</span>)) <span class="op">/</span> (<span class="bu">float</span>)(<span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>)
    <span class="cf">return</span> pi</code></pre></div>
<p>This would result in the following execution:</p>
<pre class="input"><code>$ python approx_pi_numba1.py 100000000</code></pre>
<pre class="output"><code>PI is approximately 3.1415926435893260, Error is 0.0000000100004671
Time = 0.9381080000000001 sec</code></pre>
<p>Also, keep in mind that, altough it might be worth a try, applying the Numba <span class="citation">@jit</span> annotation doesn’t provid much more gain when your code already uses Numpy:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="at">@jit</span>
<span class="kw">def</span> approx_pi(intervals):
    pi1 <span class="op">=</span> <span class="dv">4</span><span class="op">/</span>numpy.arange(<span class="dv">1</span>, intervals, <span class="dv">4</span>)
    pi2 <span class="op">=</span> <span class="op">-</span><span class="dv">4</span><span class="op">/</span>numpy.arange(<span class="dv">3</span>, intervals, <span class="dv">4</span>)
    <span class="cf">return</span> numpy.<span class="bu">sum</span>(pi1) <span class="op">+</span> numpy.<span class="bu">sum</span>(pi2)</code></pre></div>
<pre class="input"><code>$ python approx_pi_numba2.py 100000000</code></pre>
<pre class="output"><code>PI is approximately 3.1415926335840005, Error is 0.0000000200057926
Time = 0.7805560000000000 sec</code></pre>
        </div>
      </div>
      </article>
      <div class="footer">
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
  </body>
</html>
